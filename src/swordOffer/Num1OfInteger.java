package swordOffer;

/**
 * @author:create by jinhuajina
 * @Time : 2019/3/11
 * @Blog : buxuandeweilai
 */

//题目描述
//求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

public class Num1OfInteger {

    public int NumberOf1Between1AndN_Solution(int n) {
        //任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）
        //考虑十进制的各个位置上1的数量
        //当前位置1出现的次数由更高位，当前位，更低位三个方面影响
        //细分：当前位分为0|1|2~9
        //举例说明 （1）1203 先只考虑十位上的数是0，则 十位上出现1的数字范围是 10-19 110-119 210-219 ... 1010-1019 1110-1119,个数为12 * 10 = 高位上的数 * 进制位
        //（2）1213 考虑十位上的数是0，则 十位上出现1的数字范围是 10-19 110-119 210-219 ... 1010-1019 1110-1119 1210-1213,个数为12 * 10 + （13-10）+1 = 高位上的数 * 进制位 + 地位的数+1
        //（3）1223 考虑十位上的数是0，则 十位上出现1的数字范围是 10-19 110-119 210-219 ... 1010-1019 1110-1119 1210-1219个数为（12+1） * 10 = （高位上的数+1） * 进制位
        // 注意一点：1111 这个数出现了4个1，而每次统计的只是各个进制位上出现的次数。比如统计个位上1的次数是，11算了一次，统计十位上的数时，11又算了一次，虽然看上去两个数重复了，但其实每次统计的是不同进制位上的1，必须相加起来才不会漏数

        int high = 0, low = 0, cur = 1, unit = 1 ,sum = 0;

        while((n / unit)>0){     // 1234十进制
            high = n / (unit*10); // 高位 1234 / （10*10）= 12
            cur = n / unit - high * 10; //当前位 1234 / 10 - 12 * 10 = 123 - 120 = 3
            if(cur == 0){
                sum += high * unit ;
            }else if(cur == 1){
                low = n % unit + 1; //低位 1234 % 10 = 4 + 1 （1210 1211 1212 1213 1214） = 5
                sum += high * unit + low;
            }else
                sum += (high + 1) * unit;
            unit *= 10;
        }
        return sum;
    }
 // 1 10 11 12 13
    public static void main(String[] args) {
        Num1OfInteger num1OfInteger = new Num1OfInteger();
        int res = num1OfInteger.NumberOf1Between1AndN_Solution(100);
        System.out.println(res);
    }
}
